# 학생 관리 시스템 데이터 흐름 시각화

## 📌 프로그램 구조

### 클래스 구조

```
┌─────────────────────────────────────┐
│  StudentApplication (메인 클래스)   │
├─────────────────────────────────────┤
│ - studentsArray: Student[100]       │
│ - scanner: Scanner                  │
├─────────────────────────────────────┤
│ + main()                            │
│ - registerStudent()                 │
│ - studentList()                     │
│ - searchStudent()                   │
│ - updateStudent()                   │
│ - deleteStudent()                   │
│ - findStudent()                     │
└─────────────────────────────────────┘
              │
              │ 사용
              ▼
┌─────────────────────────────────────┐
│       Student (학생 클래스)          │
├─────────────────────────────────────┤
│ - studentId: String (학번)          │
│ - name: String (이름)               │
│ - age: int (나이)                   │
│ - major: String (전공)              │
├─────────────────────────────────────┤
│ + getStudentId()                    │
│ + getName()                         │
│ + getAge()                          │
│ + getMajor()                        │
│ + setName()                         │
│ + setAge()                          │
│ + setMajor()                        │
└─────────────────────────────────────┘
```

---

## 1️⃣ 배열 구조

### studentsArray 초기 상태

```
┌─────────────────────────────────────────────────────────┐
│          studentsArray (Student[100])                    │
├─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┬──────┤
│ [0] │ [1] │ [2] │ [3] │ ... │[99] │     │     │      │
├─────┼─────┼─────┼─────┼─────┼─────┼─────┼─────┼──────┤
│null │null │null │null │ ... │null │     │     │      │
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┴──────┘
     ↑
   모든 요소가 null (초기 상태)
```

**표로 표현:**

| 인덱스 | 값 |
|--------|-----|
| [0] | null |
| [1] | null |
| [2] | null |
| [3] | null |
| ... | ... |
| [99] | null |

---

## 2️⃣ 학생 등록 (registerStudent)

### 실행 흐름

```
사용자 입력
    ↓
학번: "2024001"
이름: "홍길동"
나이: 20
전공: "컴퓨터공학"
    ↓
findStudent("2024001") 호출
    ↓
배열에서 학생 찾기
    ↓
학생이 없으면 → 새 Student 객체 생성
    ↓
배열의 빈 자리(null)에 저장
```

### 메모리 구조 변화

#### 1단계: Student 객체 생성

```
┌─────────────────────────────────────┐
│         Heap 메모리                  │
├─────────────────────────────────────┤
│                                     │
│  ┌───────────────────────────────┐ │
│  │   Student 객체                │ │
│  │   studentId: "2024001"        │ │
│  │   name: "홍길동"              │ │
│  │   age: 20                     │ │
│  │   major: "컴퓨터공학"         │ │
│  └───────────┬───────────────────┘ │
│              │                      │
└──────────────┼──────────────────────┘
               │ 참조
               │
┌──────────────▼──────────────────────┐
│    studentsArray[0]                 │
│    = newStudent                     │
└─────────────────────────────────────┘
```

### 2-1. 첫 번째 학생 등록

**입력:**
- 학번: "2024001"
- 이름: "홍길동"
- 나이: 20
- 전공: "컴퓨터공학"

**배열 상태 변화:**

| 단계 | [0] | [1] | [2] | [3] | ... | [99] |
|------|-----|-----|-----|-----|-----|------|
| **초기 상태** | null | null | null | null | ... | null |
| **등록 후** | Student 객체<br>(2024001, 홍길동, 20, 컴퓨터공학) | null | null | null | ... | null |

**상세 데이터:**

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 20 | 컴퓨터공학 |
| [1] | null | - | - | - | - |
| [2] | null | - | - | - | - |
| [3] | null | - | - | - | - |

### 2-2. 두 번째 학생 등록

**입력:**
- 학번: "2024002"
- 이름: "김철수"
- 나이: 21
- 전공: "소프트웨어"

**배열 상태 변화:**

| 단계 | [0] | [1] | [2] | [3] | ... | [99] |
|------|-----|-----|-----|-----|-----|------|
| **등록 전** | Student<br>(2024001) | null | null | null | ... | null |
| **등록 후** | Student<br>(2024001) | Student 객체<br>(2024002, 김철수, 21, 소프트웨어) | null | null | ... | null |

**상세 데이터:**

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 20 | 컴퓨터공학 |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | null | - | - | - | - |
| [3] | null | - | - | - | - |

### 2-3. 세 번째 학생 등록

**입력:**
- 학번: "2024003"
- 이름: "이영희"
- 나이: 19
- 전공: "정보통신"

**배열 상태 변화:**

| 단계 | [0] | [1] | [2] | [3] | ... | [99] |
|------|-----|-----|-----|-----|-----|------|
| **등록 전** | Student<br>(2024001) | Student<br>(2024002) | null | null | ... | null |
| **등록 후** | Student<br>(2024001) | Student<br>(2024002) | Student 객체<br>(2024003, 이영희, 19, 정보통신) | null | ... | null |

**상세 데이터:**

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 20 | 컴퓨터공학 |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | null | - | - | - | - |

---

## 3️⃣ 학생 목록 (studentList)

### 실행 흐름

```
studentList() 호출
    ↓
배열을 순회 (0부터 99까지)
    ↓
null이 아닌 Student 객체 찾기
    ↓
각 Student의 정보 출력
```

### 현재 배열 상태

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 20 | 컴퓨터공학 |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | null | - | - | - | - |
| [4] | null | - | - | - | - |
| ... | ... | ... | ... | ... | ... |
| [99] | null | - | - | - | - |

### 출력 결과

```
----------- 
학생목록
----------- 
2024001 홍길동   20 컴퓨터공학
2024002 김철수   21 소프트웨어
2024003 이영희   19 정보통신
```

**처리 과정:**

1. `i = 0`: `studentsArray[0] != null` → 출력 (홍길동)
2. `i = 1`: `studentsArray[1] != null` → 출력 (김철수)
3. `i = 2`: `studentsArray[2] != null` → 출력 (이영희)
4. `i = 3`: `studentsArray[3] == null` → 건너뜀
5. ... `i = 99`: 모두 null → 종료

---

## 4️⃣ 학생 검색 (searchStudent)

### 실행 흐름

```
사용자 입력: 학번 "2024002"
    ↓
findStudent("2024002") 호출
    ↓
배열을 순회하며 학번 비교
    ↓
학번이 일치하는 Student 찾기
    ↓
Student 반환 또는 null 반환
```

### 검색 과정 시각화

**입력:** 학번 "2024002"

**배열 상태:**

| 인덱스 | Student 객체 | 학번 | 비교 결과 |
|--------|-------------|------|----------|
| [0] | ✅ | 2024001 | ❌ "2024001" != "2024002" |
| [1] | ✅ | 2024002 | ✅ "2024002" == "2024002" → **찾음!** |
| [2] | ✅ | 2024003 | (검색 종료, 이미 찾음) |

**검색 결과:**

```
----------- 
학생검색
----------- 
학번: 2024002
결과: 학생을 찾았습니다.
학번: 2024002, 이름: 김철수, 나이: 21, 전공: 소프트웨어
```

### 검색 실패 경우

**입력:** 학번 "2024999" (존재하지 않는 학번)

**배열 상태:**

| 인덱스 | Student 객체 | 학번 | 비교 결과 |
|--------|-------------|------|----------|
| [0] | ✅ | 2024001 | ❌ |
| [1] | ✅ | 2024002 | ❌ |
| [2] | ✅ | 2024003 | ❌ |
| [3] | null | - | 건너뜀 |
| ... | ... | ... | ... |
| [99] | null | - | 건너뜀 |

**검색 결과:**

```
----------- 
학생검색
----------- 
학번: 2024999
결과: 학생을 찾을 수 없습니다.
```

---

## 5️⃣ 학생 수정 (updateStudent)

### 실행 흐름

```
사용자 입력: 학번 "2024001"
    ↓
findStudent("2024001") 호출 → Student 객체 찾기
    ↓
새로운 정보 입력
    이름: "홍길동" (변경 없음)
    나이: 21 (20 → 21로 변경)
    전공: "소프트웨어" (컴퓨터공학 → 소프트웨어로 변경)
    ↓
Student 객체의 Setter 메서드 호출
    student.setName("홍길동")
    student.setAge(21)
    student.setMajor("소프트웨어")
    ↓
객체의 필드 값 변경
```

### 수정 전 배열 상태

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | **20** | **컴퓨터공학** |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |

### 수정 과정

**입력:**
- 학번: "2024001"
- 이름(수정): "홍길동"
- 나이(수정): 21
- 전공(수정): "소프트웨어"

**메모리 변화:**

```
수정 전:
┌───────────────────────────────┐
│   Student 객체 (studentsArray[0]) │
│   studentId: "2024001"        │
│   name: "홍길동"              │
│   age: 20  ←───── 변경        │
│   major: "컴퓨터공학" ←── 변경 │
└───────────────────────────────┘

수정 후:
┌───────────────────────────────┐
│   Student 객체 (studentsArray[0]) │
│   studentId: "2024001"        │
│   name: "홍길동"              │
│   age: 21  ←───── 변경됨      │
│   major: "소프트웨어" ←── 변경됨 │
└───────────────────────────────┘
```

**주의:** 배열의 인덱스는 변경되지 않고, 같은 Student 객체의 필드 값만 변경됩니다!

### 수정 후 배열 상태

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | **21** ⬆️ | **소프트웨어** ⬆️ |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |

**변경 사항:**
- `studentsArray[0]`의 age: 20 → 21
- `studentsArray[0]`의 major: "컴퓨터공학" → "소프트웨어"

---

## 6️⃣ 학생 삭제 (deleteStudent)

### 실행 흐름

```
사용자 입력: 학번 "2024002"
    ↓
findStudent("2024002") 호출 → Student 객체 찾기
    ↓
배열을 순회하며 해당 Student 객체 찾기
    ↓
해당 위치를 null로 설정
    studentsArray[i] = null;
    ↓
객체는 가비지 컬렉션에 의해 제거됨
```

### 삭제 전 배열 상태

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 21 | 소프트웨어 |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | null | - | - | - | - |

### 삭제 과정

**입력:** 학번 "2024002"

**배열 상태 변화:**

| 단계 | [0] | [1] | [2] | [3] |
|------|-----|-----|-----|-----|
| **삭제 전** | Student<br>(2024001) | Student<br>(2024002) | Student<br>(2024003) | null |
| **삭제 후** | Student<br>(2024001) | **null** ⬅️ | Student<br>(2024003) | null |

### 삭제 후 배열 상태

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 21 | 소프트웨어 |
| [1] | **null** ⬅️ | - | - | - | - |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | null | - | - | - | - |

**메모리 변화:**

```
삭제 전:
┌───────────────────────────────┐
│   Student 객체 (김철수)        │
│   studentId: "2024002"        │
│   name: "김철수"              │
│   age: 21                     │
│   major: "소프트웨어"         │
└───────────┬───────────────────┘
            │ 참조
studentsArray[1] ──┘

삭제 후:
studentsArray[1] = null;
            │
            │ 참조 끊김
            ▼
┌───────────────────────────────┐
│   Student 객체 (김철수)        │
│   → 가비지 컬렉션 대상         │
└───────────────────────────────┘
```

**주의:**
- 배열의 인덱스 [1]이 `null`로 변경됩니다.
- [2]에 있던 Student 객체는 그대로 남아있습니다. (인덱스는 이동하지 않음)

---

## 7️⃣ 전체 과정 종합 예제

### 시나리오: 여러 작업을 순차적으로 수행

#### 초기 상태

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | null | - | - | - | - |
| [1] | null | - | - | - | - |
| [2] | null | - | - | - | - |
| [3] | null | - | - | - | - |

#### 작업 1: 학생 3명 등록

**등록 데이터:**
1. 학번: "2024001", 이름: "홍길동", 나이: 20, 전공: "컴퓨터공학"
2. 학번: "2024002", 이름: "김철수", 나이: 21, 전공: "소프트웨어"
3. 학번: "2024003", 이름: "이영희", 나이: 19, 전공: "정보통신"

**등록 후 배열 상태:**

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 20 | 컴퓨터공학 |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | null | - | - | - | - |

#### 작업 2: 학생 1명 추가 등록

**등록 데이터:**
- 학번: "2024004", 이름: "박민수", 나이: 22, 전공: "컴퓨터공학"

**등록 후 배열 상태:**

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 20 | 컴퓨터공학 |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | ✅ | 2024004 | 박민수 | 22 | 컴퓨터공학 |
| [4] | null | - | - | - | - |

#### 작업 3: 학생 정보 수정

**수정 데이터:**
- 학번: "2024001"
- 이름: "홍길동" (변경 없음)
- 나이: 21 (20 → 21)
- 전공: "소프트웨어" (컴퓨터공학 → 소프트웨어)

**수정 후 배열 상태:**

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | **21** ⬆️ | **소프트웨어** ⬆️ |
| [1] | ✅ | 2024002 | 김철수 | 21 | 소프트웨어 |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | ✅ | 2024004 | 박민수 | 22 | 컴퓨터공학 |
| [4] | null | - | - | - | - |

#### 작업 4: 학생 삭제

**삭제 데이터:**
- 학번: "2024002"

**삭제 후 배열 상태:**

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 21 | 소프트웨어 |
| [1] | **null** ⬅️ | - | - | - | - |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | ✅ | 2024004 | 박민수 | 22 | 컴퓨터공학 |
| [4] | null | - | - | - | - |

#### 작업 5: 학생 목록 출력

**출력 결과:**

```
----------- 
학생목록
----------- 
2024001 홍길동   21 소프트웨어
2024003 이영희   19 정보통신
2024004 박민수   22 컴퓨터공학
```

**처리 과정:**

1. `i = 0`: `studentsArray[0] != null` → 출력 (홍길동)
2. `i = 1`: `studentsArray[1] == null` → 건너뜀
3. `i = 2`: `studentsArray[2] != null` → 출력 (이영희)
4. `i = 3`: `studentsArray[3] != null` → 출력 (박민수)
5. `i = 4`: `studentsArray[4] == null` → 건너뜀

---

## 8️⃣ 핵심 개념 정리

### 배열 관리 패턴

#### 1. 등록: 빈 자리 찾기

```java
for (int i = 0; i < studentsArray.length; i++) {
    if (studentsArray[i] == null) {  // 빈 자리 찾기
        studentsArray[i] = newStudent;  // 저장
        break;
    }
}
```

**특징:**
- 항상 앞에서부터 빈 자리를 찾습니다.
- 첫 번째로 만난 `null` 위치에 저장합니다.

#### 2. 삭제: null로 설정

```java
for (int i = 0; i < studentsArray.length; i++) {
    if (studentsArray[i] != null && 
        studentsArray[i].getStudentId().equals(studentId)) {
        studentsArray[i] = null;  // null로 설정
        break;
    }
}
```

**특징:**
- 삭제 후에도 배열 크기는 변하지 않습니다.
- 인덱스는 이동하지 않습니다. (빈 공간이 생김)

#### 3. 목록: null 체크

```java
for (int i = 0; i < studentsArray.length; i++) {
    if (studentsArray[i] != null) {  // null 체크 필수!
        // Student 정보 출력
    }
}
```

**특징:**
- `null`이 아닌 요소만 처리합니다.
- 빈 공간은 자동으로 건너뜁니다.

### 데이터 저장 구조

```
studentsArray[인덱스] → Student 객체 → 필드 값들
         │
         │ 참조 (주소)
         ▼
    Heap 메모리
    ┌─────────────┐
    │ studentId   │
    │ name        │
    │ age         │
    │ major       │
    └─────────────┘
```

### 주의사항

1. **null 체크 필수**: 배열 접근 전에 항상 `null` 체크
2. **인덱스 이동 없음**: 삭제 후에도 다른 요소의 인덱스는 변경되지 않음
3. **빈 공간 발생**: 삭제하면 배열에 빈 공간(null)이 생김
4. **순차 저장**: 등록 시 앞에서부터 빈 자리에 순서대로 저장

---

## 9️⃣ 은행 애플리케이션과 비교

| 구분 | 은행 애플리케이션 | 학생 관리 시스템 |
|------|-----------------|----------------|
| **배열 타입** | Account[] | Student[] |
| **등록** | 계좌 생성 (예금 포함) | 학생 등록 |
| **목록** | 계좌 목록 | 학생 목록 |
| **검색** | 계좌 찾기 (보조) | 학생 검색 |
| **수정** | ❌ (없음) | ✅ 학생 정보 수정 |
| **삭제** | ❌ (없음) | ✅ 학생 삭제 |
| **배열 관리** | 동일 (null 체크, 빈 자리 찾기) | 동일 |

---

## 📚 학습 요약

### 핵심 포인트

1. **배열 초기화**: 모든 요소가 `null`
2. **등록**: 빈 자리(null)를 찾아 Student 객체 저장
3. **목록**: `null`이 아닌 요소만 출력
4. **검색**: 배열 순회하며 학번 비교
5. **수정**: Student 객체의 필드 값 변경 (같은 객체)
6. **삭제**: 해당 위치를 `null`로 설정

### 데이터 흐름

```
등록: null → Student 객체
수정: Student 객체 (필드 값 변경)
삭제: Student 객체 → null
```

---

## 🔍 실습 문제

다음 작업을 순서대로 수행했을 때, 최종 배열 상태를 표로 나타내세요.

1. 학생 등록: 학번 "2024001", 이름 "홍길동", 나이 20, 전공 "컴퓨터공학"
2. 학생 등록: 학번 "2024002", 이름 "김철수", 나이 21, 전공 "소프트웨어"
3. 학생 등록: 학번 "2024003", 이름 "이영희", 나이 19, 전공 "정보통신"
4. 학생 수정: 학번 "2024001"의 나이를 21로 수정
5. 학생 삭제: 학번 "2024002" 삭제
6. 학생 등록: 학번 "2024004", 이름 "박민수", 나이 22, 전공 "컴퓨터공학"

**답:**

| 인덱스 | Student 객체 | 학번 | 이름 | 나이 | 전공 |
|--------|-------------|------|------|------|------|
| [0] | ✅ | 2024001 | 홍길동 | 21 | 컴퓨터공학 |
| [1] | null | - | - | - | - |
| [2] | ✅ | 2024003 | 이영희 | 19 | 정보통신 |
| [3] | ✅ | 2024004 | 박민수 | 22 | 컴퓨터공학 |

**설명:**
- [0]: 홍길동 등록 → 수정 (나이 20→21)
- [1]: 김철수 등록 → 삭제 (null)
- [2]: 이영희 등록 (그대로)
- [3]: 박민수 등록 (빈 자리 [1] 다음에 저장)


