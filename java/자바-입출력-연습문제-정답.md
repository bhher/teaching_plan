# 자바 입출력 연습 문제 정답 및 해설

## 문제 1: 간단한 메모장 프로그램 정답

### MemoPad.java

```java
import java.io.*;
import java.util.Scanner;

public class MemoPad {
    private static final String OUTPUT_FILE = "c:/Users/TJ/out1.txt";
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            System.out.println("=== 메모장 프로그램 ===");
            System.out.println("1. 새 메모 작성");
            System.out.println("2. 메모 읽기");
            System.out.println("3. 메모 추가");
            System.out.println("4. 종료");
            System.out.print("선택 > ");
            
            int choice = sc.nextInt();
            sc.nextLine();  // 버퍼 비우기
            
            switch (choice) {
                case 1:
                    writeNewMemo(sc);
                    break;
                case 2:
                    readMemo();
                    break;
                case 3:
                    appendMemo(sc);
                    break;
                case 4:
                    System.out.println("프로그램을 종료합니다.");
                    sc.close();
                    return;
                default:
                    System.out.println("잘못된 선택입니다.");
            }
            System.out.println();
        }
    }
    
    // 새 메모 작성 (덮어쓰기)
    public static void writeNewMemo(Scanner sc) {
        System.out.println("메모 내용 입력 (종료: 빈 줄 입력):");
        StringBuilder content = new StringBuilder();
        String line;
        
        while (true) {
            line = sc.nextLine();
            if (line.isEmpty()) {
                break;
            }
            content.append(line).append("\n");
        }
        
        // 출력 디렉토리 확인 및 생성
        File outputFile = new File(OUTPUT_FILE);
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
            System.out.println("디렉토리가 생성되었습니다: " + parentDir.getPath());
        }
        
        // 파일 존재 여부 확인
        boolean fileExists = outputFile.exists();
        
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(OUTPUT_FILE))) {  // 파일이 없으면 생성, 있으면 덮어쓰기
            bw.write(content.toString());
            if (fileExists) {
                System.out.println("기존 파일을 덮어쓰고 " + OUTPUT_FILE + "에 저장되었습니다.");
            } else {
                System.out.println("새 파일을 생성하여 " + OUTPUT_FILE + "에 저장되었습니다.");
            }
        } catch (IOException e) {
            System.out.println("파일 쓰기 오류: " + e.getMessage());
        }
    }
    
    // 메모 읽기
    public static void readMemo() {
        File file = new File(OUTPUT_FILE);
        if (!file.exists()) {
            System.out.println("파일이 없습니다.");
            return;
        }
        
        try (BufferedReader br = new BufferedReader(
                new FileReader(OUTPUT_FILE))) {
            System.out.println("=== 메모 내용 ===");
            String line;
            while ((line = br.readLine()) != null) {
                System.out.println(line);
            }
        } catch (IOException e) {
            System.out.println("파일 읽기 오류: " + e.getMessage());
        }
    }
    
    // 메모 추가 (append 모드)
    public static void appendMemo(Scanner sc) {
        System.out.println("추가할 내용 입력 (종료: 빈 줄 입력):");
        StringBuilder content = new StringBuilder();
        String line;
        
        while (true) {
            line = sc.nextLine();
            if (line.isEmpty()) {
                break;
            }
            content.append(line).append("\n");
        }
        
        // 출력 디렉토리 확인 및 생성
        File outputFile = new File(OUTPUT_FILE);
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
        }
        
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(OUTPUT_FILE, true))) {  // append 모드
            bw.write(content.toString());
            System.out.println("메모가 " + OUTPUT_FILE + "에 추가되었습니다.");
        } catch (IOException e) {
            System.out.println("파일 쓰기 오류: " + e.getMessage());
        }
    }
}
```

**해설:**
- **고정된 파일 경로**: `c:/Users/TJ/out1.txt`를 상수로 정의하여 사용
- **디렉토리 자동 생성**: `mkdirs()`로 부모 디렉토리가 없으면 자동 생성
- **파일 생성/덮어쓰기**: 
  - `FileWriter(OUTPUT_FILE)`는 파일이 없으면 자동으로 생성하고, 있으면 덮어쓰기
  - `file.exists()`로 파일 존재 여부를 확인하여 적절한 메시지 출력
- `writeNewMemo()`: 파일이 없으면 새로 생성하고, 있으면 기존 내용을 덮어쓰기
- `readMemo()`: 파일 존재 확인 후 `BufferedReader`로 읽기 (파일명 입력 불필요)
- `appendMemo()`: `FileWriter(filename, true)`로 추가 모드 사용
- `sc.nextLine()`으로 버퍼 비우기 주의

**실행 결과 예시:**
```
=== 메모장 프로그램 ===
1. 새 메모 작성
2. 메모 읽기
3. 메모 추가
4. 종료
선택 > 1
메모 내용 입력 (종료: 빈 줄 입력):
안녕하세요
자바 파일 입출력 연습입니다.
새 파일을 생성하여 c:/Users/TJ/out1.txt에 저장되었습니다.

선택 > 1
메모 내용 입력 (종료: 빈 줄 입력):
수정된 메모입니다.
기존 파일을 덮어쓰고 c:/Users/TJ/out1.txt에 저장되었습니다.

선택 > 2
=== 메모 내용 ===
안녕하세요
자바 파일 입출력 연습입니다.

선택 > 3
추가할 내용 입력 (종료: 빈 줄 입력):
추가 메모입니다.
메모가 c:/Users/TJ/out1.txt에 추가되었습니다.
```

---

## 문제 2: 학생 성적 관리 프로그램 정답

### Student.java

```java
public class Student {
    private String name;
    private int score;
    
    public Student(String name, int score) {
        this.name = name;
        this.score = score;
    }
    
    // 파일 저장용 문자열
    public String toFileString() {
        return name + "|" + score;
    }
    
    // 파일에서 읽은 문자열로 객체 생성
    public static Student fromFileString(String line) {
        try {
            String[] parts = line.split("\\|");
            if (parts.length == 2) {
                String name = parts[0].trim();
                int score = Integer.parseInt(parts[1].trim());
                return new Student(name, score);
            }
        } catch (NumberFormatException e) {
            return null;
        }
        return null;
    }
    
    // Getter
    public String getName() {
        return name;
    }
    
    public int getScore() {
        return score;
    }
    
    @Override
    public String toString() {
        return name + ": " + score + "점";
    }
}
```

### StudentManager.java

```java
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class StudentManager {
    private ArrayList<Student> students;
    private String filename;
    
    public StudentManager() {
        this.students = new ArrayList<>();
        this.filename = "students.txt";
    }
    
    // 파일에서 학생 정보 읽기
    public void loadFromFile() {
        File file = new File(filename);
        if (!file.exists()) {
            System.out.println("파일이 없습니다. 새로 시작합니다.");
            return;
        }
        
        try (BufferedReader br = new BufferedReader(
                new FileReader(filename))) {
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    Student student = Student.fromFileString(line);
                    if (student != null) {
                        students.add(student);
                    }
                }
            }
            System.out.println("파일 불러오기 완료! (" + students.size() + "명)");
        } catch (IOException e) {
            System.out.println("파일 읽기 오류: " + e.getMessage());
        }
    }
    
    // 파일에 학생 정보 저장
    public void saveToFile() {
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(filename))) {
            for (Student student : students) {
                bw.write(student.toFileString());
                bw.newLine();
            }
            System.out.println("파일 저장 완료!");
        } catch (IOException e) {
            System.out.println("파일 저장 오류: " + e.getMessage());
        }
    }
    
    // 학생 추가
    public void addStudent(String name, int score) {
        students.add(new Student(name, score));
        System.out.println("학생이 추가되었습니다.");
    }
    
    // 전체 조회
    public void printAll() {
        if (students.isEmpty()) {
            System.out.println("등록된 학생이 없습니다.");
            return;
        }
        System.out.println("=== 학생 목록 ===");
        for (int i = 0; i < students.size(); i++) {
            System.out.println((i + 1) + ". " + students.get(i));
        }
    }
    
    // 평균 계산
    public void calculateAverage() {
        if (students.isEmpty()) {
            System.out.println("학생이 없습니다.");
            return;
        }
        
        int sum = 0;
        for (Student student : students) {
            sum += student.getScore();
        }
        
        double average = (double) sum / students.size();
        System.out.println("전체 학생 수: " + students.size() + "명");
        System.out.println("평균 점수: " + average + "점");
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        StudentManager manager = new StudentManager();
        
        while (true) {
            System.out.println("\n=== 학생 성적 관리 ===");
            System.out.println("1. 학생 추가");
            System.out.println("2. 전체 조회");
            System.out.println("3. 파일 저장");
            System.out.println("4. 파일 불러오기");
            System.out.println("5. 평균 계산");
            System.out.println("6. 종료");
            System.out.print("선택 > ");
            
            int choice = sc.nextInt();
            sc.nextLine();  // 버퍼 비우기
            
            switch (choice) {
                case 1:
                    System.out.print("이름 입력: ");
                    String name = sc.nextLine();
                    System.out.print("점수 입력: ");
                    int score = sc.nextInt();
                    manager.addStudent(name, score);
                    break;
                case 2:
                    manager.printAll();
                    break;
                case 3:
                    manager.saveToFile();
                    break;
                case 4:
                    manager.loadFromFile();
                    break;
                case 5:
                    manager.calculateAverage();
                    break;
                case 6:
                    System.out.println("프로그램을 종료합니다.");
                    sc.close();
                    return;
                default:
                    System.out.println("잘못된 선택입니다.");
            }
        }
    }
}
```

**해설:**
- `toFileString()`: 파이프 구분자로 저장
- `fromFileString()`: 파이프로 분리하여 객체 생성
- `loadFromFile()`: 파일이 없으면 새로 시작
- `calculateAverage()`: double로 나눠서 소수점 계산

---

## 문제 3: 로그 분석기 정답

### LogAnalyzer.java

```java
import java.io.*;
import java.util.*;

public class LogAnalyzer {
    private ArrayList<String> logs;
    
    public LogAnalyzer() {
        this.logs = new ArrayList<>();
    }
    
    // 로그 파일 읽기
    public void loadLogFile(String filename) {
        logs.clear();
        try (BufferedReader br = new BufferedReader(
                new FileReader(filename))) {
            String line;
            while ((line = br.readLine()) != null) {
                logs.add(line);
            }
            System.out.println("로그 파일 읽기 완료! (" + logs.size() + "줄)");
        } catch (FileNotFoundException e) {
            System.out.println("파일을 찾을 수 없습니다.");
        } catch (IOException e) {
            System.out.println("파일 읽기 오류: " + e.getMessage());
        }
    }
    
    // 키워드 검색
    public void searchKeyword(String keyword) {
        System.out.println("=== 검색 결과 ===");
        boolean found = false;
        for (int i = 0; i < logs.size(); i++) {
            if (logs.get(i).contains(keyword)) {
                System.out.println("[" + (i + 1) + "] " + logs.get(i));
                found = true;
            }
        }
        if (!found) {
            System.out.println("검색 결과가 없습니다.");
        }
    }
    
    // 로그 통계
    public void printStatistics() {
        if (logs.isEmpty()) {
            System.out.println("로그가 없습니다.");
            return;
        }
        
        System.out.println("=== 로그 통계 ===");
        System.out.println("전체 로그 라인 수: " + logs.size());
        
        // 로그 레벨별 개수
        Map<String, Integer> levelCount = new HashMap<>();
        for (String log : logs) {
            // [INFO], [ERROR], [WARNING] 등 추출
            if (log.contains("[INFO]")) {
                levelCount.put("INFO", levelCount.getOrDefault("INFO", 0) + 1);
            } else if (log.contains("[ERROR]")) {
                levelCount.put("ERROR", levelCount.getOrDefault("ERROR", 0) + 1);
            } else if (log.contains("[WARNING]")) {
                levelCount.put("WARNING", levelCount.getOrDefault("WARNING", 0) + 1);
            }
        }
        
        System.out.println("\n로그 레벨별 개수:");
        for (Map.Entry<String, Integer> entry : levelCount.entrySet()) {
            System.out.println("[" + entry.getKey() + "]: " + entry.getValue() + "개");
        }
        
        // 단어 빈도 분석
        Map<String, Integer> wordCount = new HashMap<>();
        for (String log : logs) {
            // 로그에서 단어 추출 (한글, 영문, 숫자만)
            String[] words = log.toLowerCase()
                .replaceAll("[^가-힣a-zA-Z0-9\\s]", " ")
                .split("\\s+");
            
            for (String word : words) {
                if (word.length() > 1) {  // 1글자 단어 제외
                    wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
                }
            }
        }
        
        // 빈도순으로 정렬하여 Top 5 출력
        List<Map.Entry<String, Integer>> sortedWords = new ArrayList<>(wordCount.entrySet());
        sortedWords.sort((a, b) -> b.getValue().compareTo(a.getValue()));
        
        System.out.println("\n가장 많이 나타나는 단어 Top 5:");
        int count = Math.min(5, sortedWords.size());
        for (int i = 0; i < count; i++) {
            Map.Entry<String, Integer> entry = sortedWords.get(i);
            System.out.println((i + 1) + ". " + entry.getKey() + ": " + entry.getValue() + "회");
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        LogAnalyzer analyzer = new LogAnalyzer();
        
        while (true) {
            System.out.println("\n=== 로그 분석기 ===");
            System.out.println("1. 로그 파일 읽기");
            System.out.println("2. 키워드 검색");
            System.out.println("3. 로그 통계");
            System.out.println("4. 종료");
            System.out.print("선택 > ");
            
            int choice = sc.nextInt();
            sc.nextLine();  // 버퍼 비우기
            
            switch (choice) {
                case 1:
                    System.out.print("파일명 입력: ");
                    String filename = sc.nextLine();
                    analyzer.loadLogFile(filename);
                    break;
                case 2:
                    if (analyzer.logs.isEmpty()) {
                        System.out.println("먼저 로그 파일을 읽어주세요.");
                        break;
                    }
                    System.out.print("검색할 키워드 입력: ");
                    String keyword = sc.nextLine();
                    analyzer.searchKeyword(keyword);
                    break;
                case 3:
                    if (analyzer.logs.isEmpty()) {
                        System.out.println("먼저 로그 파일을 읽어주세요.");
                        break;
                    }
                    analyzer.printStatistics();
                    break;
                case 4:
                    System.out.println("프로그램을 종료합니다.");
                    sc.close();
                    return;
                default:
                    System.out.println("잘못된 선택입니다.");
            }
        }
    }
}
```

**해설:**
- `loadLogFile()`: 파일을 읽어서 ArrayList에 저장
- `searchKeyword()`: `contains()`로 키워드 포함 여부 확인
- `printStatistics()`: 
  - 로그 레벨은 `contains()`로 추출
  - 단어 빈도는 정규식으로 단어 추출 후 HashMap으로 카운트
  - 빈도순 정렬은 Comparator 사용

---

## 문제 4: 설정 관리자 정답

### ConfigManager.java

```java
import java.io.*;
import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;

public class ConfigManager {
    private Map<String, String> config;
    private String filename;
    
    public ConfigManager(String filename) {
        this.filename = filename;
        this.config = new HashMap<>();
        loadConfig();
    }
    
    // 설정 파일 읽기
    public void loadConfig() {
        File file = new File(filename);
        if (!file.exists()) {
            System.out.println("설정 파일이 없습니다. 새로 생성합니다.");
            return;
        }
        
        try (BufferedReader br = new BufferedReader(
                new FileReader(filename))) {
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                // 주석이나 빈 줄 무시
                if (line.startsWith("#") || line.isEmpty()) {
                    continue;
                }
                
                // key=value 형식 파싱
                int index = line.indexOf('=');
                if (index > 0) {
                    String key = line.substring(0, index).trim();
                    String value = line.substring(index + 1).trim();
                    config.put(key, value);
                }
            }
            System.out.println("설정 파일 로드 완료!");
        } catch (IOException e) {
            System.out.println("설정 파일 읽기 오류: " + e.getMessage());
        }
    }
    
    // 설정 파일 저장
    public void saveConfig() {
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(filename))) {
            bw.write("# 설정 파일");
            bw.newLine();
            bw.write("# 형식: key=value");
            bw.newLine();
            bw.newLine();
            
            for (Map.Entry<String, String> entry : config.entrySet()) {
                bw.write(entry.getKey() + "=" + entry.getValue());
                bw.newLine();
            }
            System.out.println("설정 파일 저장 완료!");
        } catch (IOException e) {
            System.out.println("설정 파일 저장 오류: " + e.getMessage());
        }
    }
    
    // 설정 값 가져오기
    public String get(String key) {
        return config.getOrDefault(key, "");
    }
    
    // 설정 값 설정하기
    public void set(String key, String value) {
        config.put(key, value);
    }
    
    // 설정 삭제
    public void remove(String key) {
        if (config.containsKey(key)) {
            config.remove(key);
            System.out.println("설정이 삭제되었습니다.");
        } else {
            System.out.println("해당 키가 없습니다.");
        }
    }
    
    // 모든 설정 출력
    public void printAll() {
        if (config.isEmpty()) {
            System.out.println("설정이 없습니다.");
            return;
        }
        System.out.println("=== 현재 설정 ===");
        for (Map.Entry<String, String> entry : config.entrySet()) {
            System.out.println(entry.getKey() + " = " + entry.getValue());
        }
    }
    
    // 특정 설정 출력
    public void print(String key) {
        String value = get(key);
        if (value.isEmpty()) {
            System.out.println("해당 키가 없습니다.");
        } else {
            System.out.println(key + " = " + value);
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        ConfigManager config = new ConfigManager("config.txt");
        
        while (true) {
            System.out.println("\n=== 설정 관리자 ===");
            System.out.println("1. 설정 조회");
            System.out.println("2. 설정 추가/수정");
            System.out.println("3. 설정 삭제");
            System.out.println("4. 파일 저장");
            System.out.println("5. 종료");
            System.out.print("선택 > ");
            
            int choice = sc.nextInt();
            sc.nextLine();  // 버퍼 비우기
            
            switch (choice) {
                case 1:
                    System.out.println("1. 전체 조회  2. 특정 키 조회");
                    System.out.print("선택 > ");
                    int subChoice = sc.nextInt();
                    sc.nextLine();
                    if (subChoice == 1) {
                        config.printAll();
                    } else {
                        System.out.print("키 입력: ");
                        String key = sc.nextLine();
                        config.print(key);
                    }
                    break;
                case 2:
                    System.out.print("키 입력: ");
                    String key = sc.nextLine();
                    System.out.print("값 입력: ");
                    String value = sc.nextLine();
                    config.set(key, value);
                    System.out.println("설정이 저장되었습니다.");
                    break;
                case 3:
                    System.out.print("삭제할 키 입력: ");
                    String deleteKey = sc.nextLine();
                    config.remove(deleteKey);
                    break;
                case 4:
                    config.saveConfig();
                    break;
                case 5:
                    System.out.println("프로그램을 종료합니다.");
                    sc.close();
                    return;
                default:
                    System.out.println("잘못된 선택입니다.");
            }
        }
    }
}
```

**해설:**
- `loadConfig()`: `indexOf('=')`로 key=value 파싱
- 주석(`#`로 시작)과 빈 줄은 무시
- `HashMap`으로 key-value 저장
- `saveConfig()`: 주석 헤더 포함하여 저장

---

## 문제 5: 파일 백업 프로그램 정답

### BackupManager.java

```java
import java.io.*;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.Scanner;

class BackupInfo {
    String originalPath;
    String backupPath;
    String timestamp;
    
    public BackupInfo(String originalPath, String backupPath, String timestamp) {
        this.originalPath = originalPath;
        this.backupPath = backupPath;
        this.timestamp = timestamp;
    }
    
    public String toFileString() {
        return originalPath + "|" + backupPath + "|" + timestamp;
    }
    
    public static BackupInfo fromFileString(String line) {
        String[] parts = line.split("\\|");
        if (parts.length == 3) {
            return new BackupInfo(parts[0], parts[1], parts[2]);
        }
        return null;
    }
    
    @Override
    public String toString() {
        return originalPath + " → " + backupPath + " (" + timestamp + ")";
    }
}

public class BackupManager {
    private static final String BACKUP_DIR = "backup";
    private static final String BACKUP_LIST_FILE = "backup_list.txt";
    private static final DateTimeFormatter FORMATTER = 
        DateTimeFormatter.ofPattern("yyyyMMdd_HHmmss");
    
    // 백업 폴더 생성
    private static void ensureBackupDir() {
        File dir = new File(BACKUP_DIR);
        if (!dir.exists()) {
            dir.mkdirs();
            System.out.println("백업 폴더가 생성되었습니다.");
        }
    }
    
    // 파일 백업
    public static void backupFile(String filePath) {
        File originalFile = new File(filePath);
        if (!originalFile.exists()) {
            System.out.println("파일이 존재하지 않습니다.");
            return;
        }
        
        ensureBackupDir();
        
        // 백업 파일명 생성 (원본명_타임스탬프.확장자)
        String originalName = originalFile.getName();
        int lastDot = originalName.lastIndexOf('.');
        String nameWithoutExt = lastDot > 0 ? 
            originalName.substring(0, lastDot) : originalName;
        String extension = lastDot > 0 ? 
            originalName.substring(lastDot) : "";
        
        String timestamp = LocalDateTime.now().format(FORMATTER);
        String backupFileName = nameWithoutExt + "_" + timestamp + extension;
        String backupPath = BACKUP_DIR + File.separator + backupFileName;
        
        // 파일 복사
        try (BufferedInputStream bis = new BufferedInputStream(
                new FileInputStream(originalFile));
             BufferedOutputStream bos = new BufferedOutputStream(
                new FileOutputStream(backupPath))) {
            
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, bytesRead);
            }
            
            // 백업 정보 저장
            String timestampStr = LocalDateTime.now()
                .format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss"));
            BackupInfo info = new BackupInfo(filePath, backupPath, timestampStr);
            saveBackupInfo(info);
            
            System.out.println("백업 완료: " + backupPath);
        } catch (IOException e) {
            System.out.println("백업 오류: " + e.getMessage());
        }
    }
    
    // 백업 정보 저장
    private static void saveBackupInfo(BackupInfo info) {
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(BACKUP_LIST_FILE, true))) {
            bw.write(info.toFileString());
            bw.newLine();
        } catch (IOException e) {
            System.out.println("백업 정보 저장 오류: " + e.getMessage());
        }
    }
    
    // 백업 목록 읽기
    public static ArrayList<BackupInfo> loadBackupList() {
        ArrayList<BackupInfo> list = new ArrayList<>();
        File file = new File(BACKUP_LIST_FILE);
        if (!file.exists()) {
            return list;
        }
        
        try (BufferedReader br = new BufferedReader(
                new FileReader(BACKUP_LIST_FILE))) {
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    BackupInfo info = BackupInfo.fromFileString(line);
                    if (info != null) {
                        list.add(info);
                    }
                }
            }
        } catch (IOException e) {
            System.out.println("백업 목록 읽기 오류: " + e.getMessage());
        }
        
        return list;
    }
    
    // 백업 목록 출력
    public static void printBackupList() {
        ArrayList<BackupInfo> list = loadBackupList();
        if (list.isEmpty()) {
            System.out.println("백업이 없습니다.");
            return;
        }
        
        System.out.println("=== 백업 목록 ===");
        for (int i = 0; i < list.size(); i++) {
            System.out.println((i + 1) + ". " + list.get(i));
        }
    }
    
    // 백업 복원
    public static void restoreBackup(int index) {
        ArrayList<BackupInfo> list = loadBackupList();
        if (index < 1 || index > list.size()) {
            System.out.println("잘못된 번호입니다.");
            return;
        }
        
        BackupInfo info = list.get(index - 1);
        File backupFile = new File(info.backupPath);
        if (!backupFile.exists()) {
            System.out.println("백업 파일이 존재하지 않습니다.");
            return;
        }
        
        // 원본 파일로 복사
        try (BufferedInputStream bis = new BufferedInputStream(
                new FileInputStream(backupFile));
             BufferedOutputStream bos = new BufferedOutputStream(
                new FileOutputStream(info.originalPath))) {
            
            byte[] buffer = new byte[1024];
            int bytesRead;
            while ((bytesRead = bis.read(buffer)) != -1) {
                bos.write(buffer, 0, bytesRead);
            }
            
            System.out.println("파일 복원 완료: " + info.originalPath);
        } catch (IOException e) {
            System.out.println("복원 오류: " + e.getMessage());
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        
        while (true) {
            System.out.println("\n=== 파일 백업 프로그램 ===");
            System.out.println("1. 파일 백업");
            System.out.println("2. 백업 목록 보기");
            System.out.println("3. 백업 복원");
            System.out.println("4. 종료");
            System.out.print("선택 > ");
            
            int choice = sc.nextInt();
            sc.nextLine();  // 버퍼 비우기
            
            switch (choice) {
                case 1:
                    System.out.print("백업할 파일 경로 입력: ");
                    String filePath = sc.nextLine();
                    backupFile(filePath);
                    break;
                case 2:
                    printBackupList();
                    break;
                case 3:
                    printBackupList();
                    System.out.print("복원할 백업 번호 입력: ");
                    int index = sc.nextInt();
                    restoreBackup(index);
                    break;
                case 4:
                    System.out.println("프로그램을 종료합니다.");
                    sc.close();
                    return;
                default:
                    System.out.println("잘못된 선택입니다.");
            }
        }
    }
}
```

**해설:**
- `ensureBackupDir()`: 백업 폴더가 없으면 생성
- `backupFile()`: 타임스탬프를 파일명에 추가하여 백업
- `BackupInfo` 클래스: 백업 정보를 저장하는 데이터 클래스
- `restoreBackup()`: 백업 파일을 원본 경로로 복사

---

## 문제 6: 회원 관리 시스템 정답

### Member.java

```java
public class Member {
    private String id;
    private String name;
    private String email;
    private String phone;
    
    public Member(String id, String name, String email, String phone) {
        this.id = id;
        this.name = name;
        this.email = email;
        this.phone = phone;
    }
    
    // 파일 저장용 문자열
    public String toFileString() {
        return id + "|" + name + "|" + email + "|" + phone;
    }
    
    // 파일에서 읽은 문자열로 객체 생성
    public static Member fromFileString(String line) {
        try {
            String[] parts = line.split("\\|");
            if (parts.length == 4) {
                return new Member(
                    parts[0].trim(),
                    parts[1].trim(),
                    parts[2].trim(),
                    parts[3].trim()
                );
            }
        } catch (Exception e) {
            return null;
        }
        return null;
    }
    
    // Getter
    public String getId() { return id; }
    public String getName() { return name; }
    public String getEmail() { return email; }
    public String getPhone() { return phone; }
    
    // Setter
    public void setName(String name) { this.name = name; }
    public void setEmail(String email) { this.email = email; }
    public void setPhone(String phone) { this.phone = phone; }
    
    @Override
    public String toString() {
        return "ID: " + id + ", 이름: " + name + 
               ", 이메일: " + email + ", 전화: " + phone;
    }
}
```

### MemberManager.java

```java
import java.io.*;
import java.util.ArrayList;
import java.util.Scanner;

public class MemberManager {
    private ArrayList<Member> members;
    private String filename;
    
    public MemberManager() {
        this.members = new ArrayList<>();
        this.filename = "members.txt";
        loadFromFile();  // 생성자에서 자동 로드
    }
    
    // 파일에서 회원 정보 읽기
    public void loadFromFile() {
        File file = new File(filename);
        if (!file.exists()) {
            System.out.println("회원 파일이 없습니다. 새로 시작합니다.");
            return;
        }
        
        try (BufferedReader br = new BufferedReader(
                new FileReader(filename))) {
            String line;
            while ((line = br.readLine()) != null) {
                line = line.trim();
                if (!line.isEmpty()) {
                    Member member = Member.fromFileString(line);
                    if (member != null) {
                        members.add(member);
                    }
                }
            }
            System.out.println("회원 정보 로드 완료! (" + members.size() + "명)");
        } catch (IOException e) {
            System.out.println("파일 읽기 오류: " + e.getMessage());
        }
    }
    
    // 파일에 회원 정보 저장
    public void saveToFile() {
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(filename))) {
            for (Member member : members) {
                bw.write(member.toFileString());
                bw.newLine();
            }
            System.out.println("파일 저장 완료!");
        } catch (IOException e) {
            System.out.println("파일 저장 오류: " + e.getMessage());
        }
    }
    
    // 회원 추가
    public void addMember(String id, String name, String email, String phone) {
        // 중복 ID 체크
        if (findMemberById(id) != null) {
            System.out.println("이미 존재하는 ID입니다.");
            return;
        }
        
        members.add(new Member(id, name, email, phone));
        System.out.println("회원이 등록되었습니다.");
        saveToFile();  // 즉시 저장
    }
    
    // ID로 회원 찾기
    public Member findMemberById(String id) {
        for (Member member : members) {
            if (member.getId().equals(id)) {
                return member;
            }
        }
        return null;
    }
    
    // 회원 조회
    public void findMember(String id) {
        Member member = findMemberById(id);
        if (member != null) {
            System.out.println("=== 회원 정보 ===");
            System.out.println(member);
        } else {
            System.out.println("회원을 찾을 수 없습니다.");
        }
    }
    
    // 회원 수정
    public void updateMember(String id, String name, String email, String phone) {
        Member member = findMemberById(id);
        if (member == null) {
            System.out.println("회원을 찾을 수 없습니다.");
            return;
        }
        
        member.setName(name);
        member.setEmail(email);
        member.setPhone(phone);
        System.out.println("회원 정보가 수정되었습니다.");
        saveToFile();  // 즉시 저장
    }
    
    // 회원 삭제
    public void deleteMember(String id) {
        Member member = findMemberById(id);
        if (member == null) {
            System.out.println("회원을 찾을 수 없습니다.");
            return;
        }
        
        members.remove(member);
        System.out.println("회원이 삭제되었습니다.");
        saveToFile();  // 즉시 저장
    }
    
    // 전체 조회
    public void printAll() {
        if (members.isEmpty()) {
            System.out.println("등록된 회원이 없습니다.");
            return;
        }
        
        System.out.println("=== 전체 회원 목록 ===");
        for (int i = 0; i < members.size(); i++) {
            System.out.println((i + 1) + ". " + members.get(i));
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        MemberManager manager = new MemberManager();
        
        while (true) {
            System.out.println("\n=== 회원 관리 시스템 ===");
            System.out.println("1. 회원 등록");
            System.out.println("2. 회원 조회");
            System.out.println("3. 회원 수정");
            System.out.println("4. 회원 삭제");
            System.out.println("5. 전체 조회");
            System.out.println("6. 파일 저장");
            System.out.println("7. 종료");
            System.out.print("선택 > ");
            
            int choice = sc.nextInt();
            sc.nextLine();  // 버퍼 비우기
            
            switch (choice) {
                case 1:
                    System.out.print("ID 입력: ");
                    String id = sc.nextLine();
                    System.out.print("이름 입력: ");
                    String name = sc.nextLine();
                    System.out.print("이메일 입력: ");
                    String email = sc.nextLine();
                    System.out.print("전화번호 입력: ");
                    String phone = sc.nextLine();
                    manager.addMember(id, name, email, phone);
                    break;
                case 2:
                    System.out.print("조회할 ID 입력: ");
                    String searchId = sc.nextLine();
                    manager.findMember(searchId);
                    break;
                case 3:
                    System.out.print("수정할 ID 입력: ");
                    String updateId = sc.nextLine();
                    Member updateMember = manager.findMemberById(updateId);
                    if (updateMember == null) {
                        System.out.println("회원을 찾을 수 없습니다.");
                        break;
                    }
                    System.out.print("새 이름 입력: ");
                    String newName = sc.nextLine();
                    System.out.print("새 이메일 입력: ");
                    String newEmail = sc.nextLine();
                    System.out.print("새 전화번호 입력: ");
                    String newPhone = sc.nextLine();
                    manager.updateMember(updateId, newName, newEmail, newPhone);
                    break;
                case 4:
                    System.out.print("삭제할 ID 입력: ");
                    String deleteId = sc.nextLine();
                    manager.deleteMember(deleteId);
                    break;
                case 5:
                    manager.printAll();
                    break;
                case 6:
                    manager.saveToFile();
                    break;
                case 7:
                    System.out.println("프로그램을 종료합니다.");
                    sc.close();
                    return;
                default:
                    System.out.println("잘못된 선택입니다.");
            }
        }
    }
}
```

**해설:**
- 생성자에서 `loadFromFile()` 호출하여 프로그램 시작 시 자동 로드
- 각 CRUD 작업 후 `saveToFile()` 호출하여 즉시 저장
- 중복 ID 체크로 데이터 무결성 유지
- 파이프 구분자로 파일 저장/읽기

---

## 공통 해설 및 팁

### 1. 파일 경로 처리

```java
// 상대 경로 (프로젝트 루트 기준)
File file = new File("data.txt");

// 절대 경로
File file = new File("C:\\Users\\user\\data.txt");

// 플랫폼 독립적인 경로 구분자
String path = "backup" + File.separator + "file.txt";
```

### 2. 예외 처리 패턴

```java
// 방법 1: try-with-resources (권장)
try (BufferedReader br = new BufferedReader(
        new FileReader("data.txt"))) {
    // 파일 읽기
} catch (FileNotFoundException e) {
    System.out.println("파일을 찾을 수 없습니다.");
} catch (IOException e) {
    System.out.println("입출력 오류: " + e.getMessage());
}

// 방법 2: 수동 close (비권장)
BufferedReader br = null;
try {
    br = new BufferedReader(new FileReader("data.txt"));
    // 파일 읽기
} catch (IOException e) {
    e.printStackTrace();
} finally {
    if (br != null) {
        try {
            br.close();
        } catch (IOException e) {
            e.printStackTrace();
        }
    }
}
```

### 3. 파일 존재 확인

```java
File file = new File("data.txt");
if (file.exists() && file.isFile()) {
    // 파일 읽기
} else {
    System.out.println("파일이 존재하지 않습니다.");
}
```

### 4. 문자열 파싱 패턴

```java
// 파이프 구분자
String[] parts = line.split("\\|");

// 쉼표 구분자
String[] parts = line.split(",");

// key=value 형식
int index = line.indexOf('=');
String key = line.substring(0, index).trim();
String value = line.substring(index + 1).trim();
```

### 5. 파일 쓰기 모드

```java
// 덮어쓰기 모드 (기본)
FileWriter fw = new FileWriter("data.txt");

// 추가 모드
FileWriter fw = new FileWriter("data.txt", true);
```

### 6. 버퍼 비우기

```java
Scanner sc = new Scanner(System.in);
int num = sc.nextInt();
sc.nextLine();  // 버퍼 비우기 (중요!)
String str = sc.nextLine();
```

---

## 실행 결과 예시

### 문제 1 실행 결과
```
=== 메모장 프로그램 ===
1. 새 메모 작성
2. 메모 읽기
3. 메모 추가
4. 종료
선택 > 1
파일명 입력: memo.txt
메모 내용 입력 (종료: 빈 줄 입력):
안녕하세요
자바 파일 입출력 연습입니다.

메모가 저장되었습니다.
```

### 문제 2 실행 결과
```
=== 학생 성적 관리 ===
1. 학생 추가
2. 전체 조회
3. 파일 저장
4. 파일 불러오기
5. 평균 계산
6. 종료
선택 > 1
이름 입력: 홍길동
점수 입력: 85
학생이 추가되었습니다.

선택 > 5
전체 학생 수: 1명
평균 점수: 85.0점
```

### 문제 3 실행 결과
```
=== 로그 분석기 ===
1. 로그 파일 읽기
2. 키워드 검색
3. 로그 통계
4. 종료
선택 > 1
파일명 입력: app.log
로그 파일 읽기 완료! (5줄)

선택 > 2
검색할 키워드 입력: 로그인
=== 검색 결과 ===
[2] [2024-01-01 10:01:00] [INFO] 사용자 로그인: 홍길동
```

### 문제 4 실행 결과
```
=== 설정 관리자 ===
1. 설정 조회
2. 설정 추가/수정
3. 설정 삭제
4. 파일 저장
5. 종료
선택 > 1
=== 현재 설정 ===
server = localhost
port = 8080
```

### 문제 5 실행 결과
```
=== 파일 백업 프로그램 ===
1. 파일 백업
2. 백업 목록 보기
3. 백업 복원
4. 종료
선택 > 1
백업할 파일 경로 입력: data.txt
백업 완료: backup/data_20240101_120000.txt
```

### 문제 6 실행 결과
```
회원 정보 로드 완료! (0명)

=== 회원 관리 시스템 ===
1. 회원 등록
2. 회원 조회
3. 회원 수정
4. 회원 삭제
5. 전체 조회
6. 파일 저장
7. 종료
선택 > 1
ID 입력: M001
이름 입력: 홍길동
이메일 입력: hong@example.com
전화번호 입력: 010-1234-5678
회원이 등록되었습니다.
파일 저장 완료!
```

---

## 문제 7: 텍스트 파일 통계 및 변환 프로그램 정답

### TextProcessor.java

```java
import java.io.*;
import java.util.*;

public class TextProcessor {
    private static final String OUTPUT_FILE = "c:/Users/TJ/out1.txt";
    private ArrayList<String> lines;
    
    public TextProcessor() {
        this.lines = new ArrayList<>();
    }
    
    // 파일 읽기 및 통계 출력
    public void readFileAndStatistics(String filePath) {
        lines.clear();
        File file = new File(filePath);
        
        if (!file.exists()) {
            System.out.println("파일이 존재하지 않습니다.");
            return;
        }
        
        try (BufferedReader br = new BufferedReader(
                new FileReader(filePath))) {
            String line;
            while ((line = br.readLine()) != null) {
                lines.add(line);
            }
            
            // 통계 계산
            printStatistics();
        } catch (IOException e) {
            System.out.println("파일 읽기 오류: " + e.getMessage());
        }
    }
    
    // 통계 출력
    private void printStatistics() {
        if (lines.isEmpty()) {
            System.out.println("파일이 비어있습니다.");
            return;
        }
        
        int totalLines = lines.size();
        int totalCharsWithSpace = 0;
        int totalCharsWithoutSpace = 0;
        int totalWords = 0;
        
        for (String line : lines) {
            totalCharsWithSpace += line.length();
            totalCharsWithoutSpace += line.replaceAll("\\s", "").length();
            
            // 단어 개수 세기 (공백으로 분리)
            String[] words = line.trim().split("\\s+");
            if (!line.trim().isEmpty()) {
                totalWords += words.length;
            }
        }
        
        System.out.println("=== 파일 통계 ===");
        System.out.println("전체 라인 수: " + totalLines);
        System.out.println("전체 문자 수 (공백 포함): " + totalCharsWithSpace);
        System.out.println("전체 문자 수 (공백 제외): " + totalCharsWithoutSpace);
        System.out.println("전체 단어 수: " + totalWords);
    }
    
    // 대문자로 변환하여 저장
    public void convertToUpperCase(String filePath) {
        if (lines.isEmpty()) {
            readFileAndStatistics(filePath);
        }
        
        ArrayList<String> upperLines = new ArrayList<>();
        for (String line : lines) {
            upperLines.add(line.toUpperCase());
        }
        
        saveToFile(upperLines);
        System.out.println("대문자로 변환하여 " + OUTPUT_FILE + "에 저장 완료!");
    }
    
    // 소문자로 변환하여 저장
    public void convertToLowerCase(String filePath) {
        if (lines.isEmpty()) {
            readFileAndStatistics(filePath);
        }
        
        ArrayList<String> lowerLines = new ArrayList<>();
        for (String line : lines) {
            lowerLines.add(line.toLowerCase());
        }
        
        saveToFile(lowerLines);
        System.out.println("소문자로 변환하여 " + OUTPUT_FILE + "에 저장 완료!");
    }
    
    // 단어 개수 세기 및 저장
    public void countWordsAndSave(String filePath) {
        if (lines.isEmpty()) {
            readFileAndStatistics(filePath);
        }
        
        // 단어 빈도 계산
        Map<String, Integer> wordCount = new HashMap<>();
        
        for (String line : lines) {
            // 단어 추출 (영문, 숫자만)
            String[] words = line.toLowerCase()
                .replaceAll("[^a-zA-Z0-9\\s]", " ")
                .split("\\s+");
            
            for (String word : words) {
                if (!word.isEmpty()) {
                    wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
                }
            }
        }
        
        // 빈도순으로 정렬
        List<Map.Entry<String, Integer>> sortedWords = new ArrayList<>(wordCount.entrySet());
        sortedWords.sort((a, b) -> {
            int compare = b.getValue().compareTo(a.getValue());  // 빈도 내림차순
            if (compare == 0) {
                return a.getKey().compareTo(b.getKey());  // 같으면 알파벳순
            }
            return compare;
        });
        
        // 파일에 저장
        File outputFile = new File(OUTPUT_FILE);
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
        }
        
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(OUTPUT_FILE))) {
            for (Map.Entry<String, Integer> entry : sortedWords) {
                bw.write(entry.getKey() + ": " + entry.getValue());
                bw.newLine();
            }
        } catch (IOException e) {
            System.out.println("파일 저장 오류: " + e.getMessage());
        }
        
        System.out.println("단어 개수 통계를 " + OUTPUT_FILE + "에 저장 완료!");
    }
    
    // 결과를 파일에 저장
    private void saveToFile(ArrayList<String> data) {
        File outputFile = new File(OUTPUT_FILE);
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
        }
        
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(OUTPUT_FILE))) {
            for (String line : data) {
                bw.write(line);
                bw.newLine();
            }
        } catch (IOException e) {
            System.out.println("파일 저장 오류: " + e.getMessage());
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        TextProcessor processor = new TextProcessor();
        
        while (true) {
            System.out.println("\n=== 텍스트 파일 처리 프로그램 ===");
            System.out.println("1. 파일 읽기 및 통계 출력");
            System.out.println("2. 대문자로 변환하여 저장");
            System.out.println("3. 소문자로 변환하여 저장");
            System.out.println("4. 단어 개수 세기 및 저장");
            System.out.println("5. 종료");
            System.out.print("선택 > ");
            
            int choice = sc.nextInt();
            sc.nextLine();  // 버퍼 비우기
            
            switch (choice) {
                case 1:
                    System.out.print("파일 경로 입력: ");
                    String filePath1 = sc.nextLine();
                    processor.readFileAndStatistics(filePath1);
                    break;
                case 2:
                    System.out.print("파일 경로 입력: ");
                    String filePath2 = sc.nextLine();
                    processor.convertToUpperCase(filePath2);
                    break;
                case 3:
                    System.out.print("파일 경로 입력: ");
                    String filePath3 = sc.nextLine();
                    processor.convertToLowerCase(filePath3);
                    break;
                case 4:
                    System.out.print("파일 경로 입력: ");
                    String filePath4 = sc.nextLine();
                    processor.countWordsAndSave(filePath4);
                    break;
                case 5:
                    System.out.println("프로그램을 종료합니다.");
                    sc.close();
                    return;
                default:
                    System.out.println("잘못된 선택입니다.");
            }
        }
    }
}
```

**해설:**

1. **통계 계산**
   ```java
   totalCharsWithoutSpace += line.replaceAll("\\s", "").length();
   ```
   - `replaceAll("\\s", "")`로 모든 공백 제거 후 길이 계산

2. **단어 분리**
   ```java
   String[] words = line.trim().split("\\s+");
   ```
   - `trim()`으로 앞뒤 공백 제거
   - `split("\\s+")`로 하나 이상의 공백으로 분리

3. **단어 빈도 계산**
   ```java
   wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);
   ```
   - `getOrDefault()`로 기존 값이 없으면 0으로 초기화

4. **정렬**
   ```java
   sortedWords.sort((a, b) -> {
       int compare = b.getValue().compareTo(a.getValue());  // 빈도 내림차순
       if (compare == 0) {
           return a.getKey().compareTo(b.getKey());  // 같으면 알파벳순
       }
       return compare;
   });
   ```
   - 빈도순으로 정렬하고, 같으면 알파벳순으로 정렬

5. **디렉토리 자동 생성**
   - 출력 파일의 부모 디렉토리가 없으면 자동 생성

**실행 결과 예시:**

```
=== 텍스트 파일 처리 프로그램 ===
1. 파일 읽기 및 통계 출력
2. 대문자로 변환하여 저장
3. 소문자로 변환하여 저장
4. 단어 개수 세기 및 저장
5. 종료
선택 > 1
파일 경로 입력: input.txt
=== 파일 통계 ===
전체 라인 수: 4
전체 문자 수 (공백 포함): 52
전체 문자 수 (공백 제외): 44
전체 단어 수: 8

선택 > 2
파일 경로 입력: input.txt
대문자로 변환하여 c:/Users/TJ/out1.txt에 저장 완료!
```

**c:/Users/TJ/out1.txt 파일 내용 (대문자 변환):**
```
HELLO WORLD
JAVA PROGRAMMING
FILE INPUT OUTPUT
HELLO JAVA
```

**c:/Users/TJ/out1.txt 파일 내용 (단어 개수):**
```
hello: 2
java: 2
world: 1
programming: 1
file: 1
input: 1
output: 1
```

---

## 문제 8: 파일 필터링 및 결과 저장 프로그램 정답

### FileFilter.java

```java
import java.io.*;
import java.util.*;

public class FileFilter {
    private static final String OUTPUT_FILE = "c:/Users/TJ/out1.txt";
    private ArrayList<String> lines;
    
    public FileFilter() {
        this.lines = new ArrayList<>();
    }
    
    // 파일 읽기
    public void readFile(String filePath) {
        lines.clear();
        File file = new File(filePath);
        
        if (!file.exists()) {
            System.out.println("파일이 존재하지 않습니다.");
            return;
        }
        
        try (BufferedReader br = new BufferedReader(
                new FileReader(filePath))) {
            String line;
            while ((line = br.readLine()) != null) {
                lines.add(line);
            }
            System.out.println("파일 읽기 완료! (" + lines.size() + "줄)");
            printFile();
        } catch (IOException e) {
            System.out.println("파일 읽기 오류: " + e.getMessage());
        }
    }
    
    // 파일 내용 출력
    private void printFile() {
        if (lines.isEmpty()) {
            System.out.println("파일이 비어있습니다.");
            return;
        }
        System.out.println("=== 파일 내용 ===");
        for (String line : lines) {
            System.out.println(line);
        }
    }
    
    // 특정 단어 포함 라인만 저장
    public void filterByContains(String filePath, String keyword) {
        if (lines.isEmpty()) {
            readFile(filePath);
        }
        
        ArrayList<String> filtered = new ArrayList<>();
        for (String line : lines) {
            if (line.contains(keyword)) {
                filtered.add(line);
            }
        }
        
        saveToFile(filtered);
        System.out.println(keyword + "가 포함된 라인을 " + OUTPUT_FILE + "에 저장 완료!");
    }
    
    // 특정 단어 제외 라인만 저장
    public void filterByNotContains(String filePath, String keyword) {
        if (lines.isEmpty()) {
            readFile(filePath);
        }
        
        ArrayList<String> filtered = new ArrayList<>();
        for (String line : lines) {
            if (!line.contains(keyword)) {
                filtered.add(line);
            }
        }
        
        saveToFile(filtered);
        System.out.println(keyword + "가 포함되지 않은 라인을 " + OUTPUT_FILE + "에 저장 완료!");
    }
    
    // 라인 길이로 필터링하여 저장
    public void filterByLength(String filePath, int minLength, int maxLength) {
        if (lines.isEmpty()) {
            readFile(filePath);
        }
        
        ArrayList<String> filtered = new ArrayList<>();
        for (String line : lines) {
            int length = line.length();
            if (length >= minLength && length <= maxLength) {
                filtered.add(line);
            }
        }
        
        saveToFile(filtered);
        System.out.println("길이 " + minLength + "~" + maxLength + "인 라인을 " + OUTPUT_FILE + "에 저장 완료!");
    }
    
    // 중복 라인 제거하여 저장
    public void removeDuplicates(String filePath) {
        if (lines.isEmpty()) {
            readFile(filePath);
        }
        
        // LinkedHashSet을 사용하여 순서 유지하면서 중복 제거
        LinkedHashSet<String> uniqueLines = new LinkedHashSet<>(lines);
        ArrayList<String> filtered = new ArrayList<>(uniqueLines);
        
        saveToFile(filtered);
        System.out.println("중복 라인 제거하여 " + OUTPUT_FILE + "에 저장 완료!");
    }
    
    // 결과를 파일에 저장
    private void saveToFile(ArrayList<String> data) {
        // 출력 디렉토리 확인 및 생성
        File outputFile = new File(OUTPUT_FILE);
        File parentDir = outputFile.getParentFile();
        if (parentDir != null && !parentDir.exists()) {
            parentDir.mkdirs();
        }
        
        try (BufferedWriter bw = new BufferedWriter(
                new FileWriter(OUTPUT_FILE))) {
            for (String line : data) {
                bw.write(line);
                bw.newLine();
            }
        } catch (IOException e) {
            System.out.println("파일 저장 오류: " + e.getMessage());
        }
    }
    
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        FileFilter filter = new FileFilter();
        
        while (true) {
            System.out.println("\n=== 파일 필터링 프로그램 ===");
            System.out.println("1. 파일 읽기");
            System.out.println("2. 특정 단어 포함 라인만 저장");
            System.out.println("3. 특정 단어 제외 라인만 저장");
            System.out.println("4. 라인 길이로 필터링하여 저장");
            System.out.println("5. 중복 라인 제거하여 저장");
            System.out.println("6. 종료");
            System.out.print("선택 > ");
            
            int choice = sc.nextInt();
            sc.nextLine();  // 버퍼 비우기
            
            switch (choice) {
                case 1:
                    System.out.print("파일 경로 입력: ");
                    String filePath = sc.nextLine();
                    filter.readFile(filePath);
                    break;
                case 2:
                    System.out.print("파일 경로 입력: ");
                    String filePath1 = sc.nextLine();
                    System.out.print("검색할 키워드 입력: ");
                    String keyword1 = sc.nextLine();
                    filter.filterByContains(filePath1, keyword1);
                    break;
                case 3:
                    System.out.print("파일 경로 입력: ");
                    String filePath2 = sc.nextLine();
                    System.out.print("제외할 키워드 입력: ");
                    String keyword2 = sc.nextLine();
                    filter.filterByNotContains(filePath2, keyword2);
                    break;
                case 4:
                    System.out.print("파일 경로 입력: ");
                    String filePath3 = sc.nextLine();
                    System.out.print("최소 길이 입력: ");
                    int minLength = sc.nextInt();
                    System.out.print("최대 길이 입력: ");
                    int maxLength = sc.nextInt();
                    sc.nextLine();
                    filter.filterByLength(filePath3, minLength, maxLength);
                    break;
                case 5:
                    System.out.print("파일 경로 입력: ");
                    String filePath4 = sc.nextLine();
                    filter.removeDuplicates(filePath4);
                    break;
                case 6:
                    System.out.println("프로그램을 종료합니다.");
                    sc.close();
                    return;
                default:
                    System.out.println("잘못된 선택입니다.");
            }
        }
    }
}
```

**해설:**

1. **파일 경로 상수화**
   ```java
   private static final String OUTPUT_FILE = "c:/Users/TJ/out1.txt";
   ```
   - 출력 파일 경로를 상수로 정의하여 유지보수 용이

2. **디렉토리 자동 생성**
   ```java
   File parentDir = outputFile.getParentFile();
   if (parentDir != null && !parentDir.exists()) {
       parentDir.mkdirs();
   }
   ```
   - 출력 파일의 부모 디렉토리가 없으면 자동 생성
   - `mkdirs()`는 중간 디렉토리까지 모두 생성

3. **중복 제거 방법**
   ```java
   LinkedHashSet<String> uniqueLines = new LinkedHashSet<>(lines);
   ```
   - `LinkedHashSet` 사용으로 순서 유지하면서 중복 제거
   - `HashSet`은 순서가 보장되지 않음

4. **필터링 로직**
   - `contains()`: 문자열 포함 여부 확인
   - `length()`: 문자열 길이 확인
   - 조건에 맞는 라인만 새로운 리스트에 추가

5. **파일 읽기 상태 관리**
   - `lines` 리스트가 비어있으면 자동으로 파일 읽기
   - 한 번 읽은 파일은 메모리에 유지하여 반복 작업 시 효율적

**실행 결과 예시:**

```
=== 파일 필터링 프로그램 ===
1. 파일 읽기
2. 특정 단어 포함 라인만 저장
3. 특정 단어 제외 라인만 저장
4. 라인 길이로 필터링하여 저장
5. 중복 라인 제거하여 저장
6. 종료
선택 > 1
파일 경로 입력: data.txt
파일 읽기 완료! (6줄)
=== 파일 내용 ===
Java Programming
Python Programming
Java Script
C++ Programming
Java Programming
Web Development

선택 > 2
파일 경로 입력: data.txt
검색할 키워드 입력: Java
Java가 포함된 라인을 c:/Users/TJ/out1.txt에 저장 완료!

선택 > 5
파일 경로 입력: data.txt
중복 라인 제거하여 c:/Users/TJ/out1.txt에 저장 완료!
```

**c:/Users/TJ/out1.txt 파일 내용 (Java 포함 필터링):**
```
Java Programming
Java Script
Java Programming
```

**c:/Users/TJ/out1.txt 파일 내용 (중복 제거):**
```
Java Programming
Python Programming
Java Script
C++ Programming
Web Development
```

---

## 주요 학습 포인트

1. **try-with-resources**: 자동 리소스 관리로 코드 간소화
2. **BufferedReader/BufferedWriter**: 성능 향상을 위한 버퍼 사용
3. **파일 형식 설계**: 구분자(파이프, 쉼표)를 사용한 데이터 저장
4. **예외 처리**: FileNotFoundException과 IOException 구분 처리
5. **데이터 영속성**: 프로그램 종료 후에도 데이터 유지
6. **자동 로드/저장**: 생성자에서 로드, 작업 후 즉시 저장
