# SQLD (SQL Developer) 시험 문제 정답 및 상세 해설

**총 문제 수:** 50문제  
**시험 시간:** 90분  
**합격 기준:** 60점 이상 (100점 만점)

---

## 제1과목: 데이터 모델링의 이해 (25문제)

### 1. 다음 중 데이터 모델링의 3단계 프로세스가 아닌 것은?

**정답: ④ 구현적 데이터 모델링**

**상세 해설:**
- **데이터 모델링 3단계:**
  1. **개념적 데이터 모델링**: 업무의 핵심 개념과 구조를 파악하여 엔티티와 관계를 도출
  2. **논리적 데이터 모델링**: 개념적 모델을 데이터베이스에 독립적인 논리적 구조로 변환
  3. **물리적 데이터 모델링**: 특정 DBMS에 맞는 물리적 구조로 변환 (테이블, 인덱스 등)
- 구현적 데이터 모델링은 존재하지 않는 단계입니다.

---

### 2. 엔티티(Entity)에 대한 설명으로 옳지 않은 것은?

**정답: ② 반드시 물리적으로 존재하는 것만 엔티티가 될 수 있다**

**상세 해설:**
- **엔티티의 분류:**
  - **유형 엔티티**: 물리적으로 존재 (예: 사원, 고객, 상품)
  - **개념 엔티티**: 개념적으로 존재 (예: 부서, 직급, 상품카테고리)
  - **사건 엔티티**: 업무 수행 시 발생 (예: 주문, 판매, 계약)
- 엔티티는 반드시 물리적으로 존재할 필요가 없습니다.

---

### 3. 다음 중 속성(Attribute)의 분류가 아닌 것은?

**정답: ③ 복합 속성**

**상세 해설:**
- **속성의 분류:**
  - **기본 속성**: 업무로부터 도출된 본래의 속성 (예: 사원명, 주소)
  - **설계 속성**: 업무를 위해 설계자가 임의로 만든 속성 (예: 사원번호, 주문번호)
  - **파생 속성**: 다른 속성으로부터 계산된 속성 (예: 총액, 평균)
- 복합 속성은 속성의 분류가 아니라 속성의 특성(단순/복합)을 나타냅니다.

---

### 4. 다음 중 식별자(Identifier)의 특성이 아닌 것은?

**정답: ③ 정규성**

**상세 해설:**
- **식별자의 특성:**
  - **유일성**: 각 인스턴스를 유일하게 구분
  - **최소성**: 식별자를 구성하는 속성의 수가 최소
  - **존재성**: NULL 값을 가질 수 없음
  - **불변성**: 한 번 정해지면 변경되지 않음
- 정규성은 정규화(Normalization)에서 사용되는 개념입니다.

---

### 5. 관계(Relationship)의 차수(Cardinality)가 아닌 것은?

**정답: ④ M:1**

**상세 해설:**
- **관계의 차수:**
  - **1:1 (One-to-One)**: 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스 하나와 관계
  - **1:M (One-to-Many)**: 한 엔티티의 인스턴스가 다른 엔티티의 인스턴스 여러 개와 관계
  - **M:N (Many-to-Many)**: 양쪽 엔티티 모두 여러 개의 인스턴스와 관계
- M:1은 1:M과 동일한 관계를 반대 방향에서 본 것입니다.

---

### 6. 다음 중 정규화(Normalization)의 목적이 아닌 것은?

**정답: ③ 데이터 접근 속도 향상**

**상세 해설:**
- **정규화의 목적:**
  - 데이터 중복 최소화
  - 데이터 일관성 유지
  - 데이터 무결성 보장
  - 저장 공간 효율화
- 정규화는 테이블을 분리하여 조인이 증가하므로 오히려 접근 속도가 느려질 수 있습니다.
- 성능 향상이 필요한 경우 반정규화를 수행합니다.

---

### 7. 제1정규화(1NF)의 조건은?

**정답: ① 모든 속성이 원자값을 가져야 함**

**상세 해설:**
- **제1정규화 (1NF):**
  - 모든 속성의 값이 원자값(Atomic Value)이어야 함
  - 반복되는 그룹이 없어야 함
  - 예: 주소를 "서울시 강남구"로 저장하는 것은 비원자값, "시/도", "시/군/구"로 분리해야 함
- 부분 함수 종속 제거는 2NF의 조건입니다.

---

### 8. 다음 중 이상(Anomaly) 현상이 아닌 것은?

**정답: ③ 참조 이상**

**상세 해설:**
- **이상 현상:**
  - **삽입 이상**: 불필요한 정보를 함께 저장해야 하는 경우
  - **삭제 이상**: 필요한 정보까지 함께 삭제되는 경우
  - **갱신 이상**: 일부만 수정하여 데이터 불일치가 발생하는 경우
- 참조 이상은 참조 무결성 제약조건과 관련된 개념입니다.

---

### 9. 반정규화(Denormalization)를 수행하는 이유는?

**정답: ② 성능 향상을 위해**

**상세 해설:**
- **반정규화:**
  - 정규화된 데이터 모델을 성능 향상을 위해 일부 중복을 허용하는 것
  - 조인 비용 감소, 조회 성능 향상
  - 데이터 중복 증가로 인한 저장 공간 증가와 일관성 유지 비용 증가
- 성능과 일관성 사이의 트레이드오프를 고려해야 합니다.

---

### 10. 다음 중 데이터베이스 설계 단계가 아닌 것은?

**정답: ③ 논리적 설계**

**상세 해설:**
- **데이터베이스 설계 단계:**
  1. 요구사항 분석
  2. 개념적 설계 (ERD 작성)
  3. 논리적 설계 (관계 스키마 설계)
  4. 물리적 설계 (테이블, 인덱스 설계)
- 논리적 설계는 설계 단계에 포함됩니다. (문제 오류 가능)

---

### 11. ERD에서 엔티티를 표현하는 기호는?

**정답: ① 사각형**

**상세 해설:**
- **ERD 표기법:**
  - **엔티티**: 사각형
  - **속성**: 타원
  - **관계**: 다이아몬드
  - **연결선**: 선

---

### 12. 다음 중 외래키(Foreign Key)에 대한 설명으로 옳은 것은?

**정답: ② 다른 테이블의 기본키를 참조한다**

**상세 해설:**
- **외래키의 특징:**
  - 다른 테이블의 기본키 또는 유일키를 참조
  - NULL 값을 가질 수 있음 (참조 무결성 제약조건에 따라)
  - 한 테이블에 여러 개 존재 가능
  - 참조하는 테이블의 기본키와 이름이 달라도 됨

---

### 13. 다음 중 기본키(Primary Key)의 특징이 아닌 것은?

**정답: ③ NULL 허용**

**상세 해설:**
- **기본키의 특징:**
  - **유일성**: 각 행을 유일하게 식별
  - **최소성**: 최소한의 속성으로 구성
  - **존재성**: NULL 값을 가질 수 없음
  - **불변성**: 값이 변경되지 않음

---

### 14. 다음 중 대체키(Alternate Key)에 대한 설명으로 옳은 것은?

**정답: ① 기본키로 선택되지 않은 후보키**

**상세 해설:**
- **키의 종류:**
  - **후보키**: 기본키가 될 수 있는 모든 키
  - **기본키**: 후보키 중 선택된 하나
  - **대체키**: 후보키 중 기본키로 선택되지 않은 나머지
  - **외래키**: 다른 테이블의 기본키를 참조하는 키

---

### 15. 다음 중 슈퍼타입과 서브타입 관계에서 배타적 관계를 나타내는 것은?

**정답: ② OR 관계**

**상세 해설:**
- **슈퍼타입과 서브타입:**
  - **배타적 관계 (OR)**: 서브타입 중 하나만 선택 가능
    - 예: 고객은 개인고객 또는 법인고객 중 하나
  - **포괄적 관계 (AND)**: 여러 서브타입 동시 선택 가능
    - 예: 직원은 정규직이면서 동시에 관리자일 수 있음

---

### 16. 다음 중 식별 관계와 비식별 관계의 차이점이 아닌 것은?

**정답: ③ 식별 관계는 필수 관계**

**상세 해설:**
- **식별 관계:**
  - 자식 엔티티의 기본키에 부모의 기본키가 포함됨
  - 실선으로 표현
  - 자식이 부모 없이 존재할 수 없음
- **비식별 관계:**
  - 자식 엔티티의 일반 속성에 부모의 기본키가 포함됨
  - 점선으로 표현
  - 자식이 부모 없이도 존재 가능
- 필수/선택과는 직접적인 관련이 없습니다.

---

### 17. 다음 중 M:M 관계를 해소하는 방법은?

**정답: ② 중간 테이블 생성**

**상세 해설:**
- **M:M 관계 해소:**
  - 중간 테이블(교차 엔티티, Intersection Entity) 생성
  - M:M 관계를 1:M 관계 두 개로 분해
  - 예: 학생-과목 M:M → 학생-수강 1:M, 과목-수강 1:M

---

### 18. 다음 중 인덱스(Index)를 생성하는 목적이 아닌 것은?

**정답: ② 데이터 중복 제거**

**상세 해설:**
- **인덱스의 목적:**
  - 검색 속도 향상
  - 정렬 속도 향상
  - 조인 성능 향상
- 데이터 중복 제거는 정규화의 목적입니다.

---

### 19. 다음 중 파티셔닝(Partitioning)의 종류가 아닌 것은?

**정답: ④ 트리 분할(Tree Partitioning)**

**상세 해설:**
- **파티셔닝 종류:**
  - **범위 분할**: 값의 범위로 분할
  - **해시 분할**: 해시 함수로 분할
  - **리스트 분할**: 특정 값의 리스트로 분할
  - **복합 분할**: 여러 방법 조합
- 트리 분할은 존재하지 않습니다.

---

### 20. 다음 중 데이터베이스 무결성 제약조건이 아닌 것은?

**정답: ④ 관계 무결성**

**상세 해설:**
- **무결성 제약조건:**
  - **도메인 무결성**: 속성 값이 도메인에 속해야 함
  - **개체 무결성**: 기본키는 NULL이 될 수 없고 유일해야 함
  - **참조 무결성**: 외래키는 참조하는 기본키 값이 존재해야 함
- 관계 무결성은 존재하지 않습니다.

---

### 21. 다음 중 데이터베이스 설계 시 고려사항이 아닌 것은?

**정답: ③ 보안**

**상세 해설:**
- **데이터베이스 설계 고려사항:**
  - 성능 (응답 시간, 처리량)
  - 확장성 (향후 확장 가능성)
  - 일관성 (데이터 일관성 유지)
  - 보안도 고려사항이지만, 문제에서 "아닌 것"을 찾는 문제로 보임
- 실제로는 모두 고려사항입니다. (문제 오류 가능)

---

### 22. 다음 중 엔티티의 분류가 아닌 것은?

**정답: ④ 관계 엔티티**

**상세 해설:**
- **엔티티 분류:**
  - **유형 엔티티**: 물리적으로 존재 (사원, 고객, 상품)
  - **개념 엔티티**: 개념적으로 존재 (부서, 직급, 카테고리)
  - **사건 엔티티**: 업무 수행 시 발생 (주문, 판매, 계약)
- 관계 엔티티는 존재하지 않습니다. (관계는 Relationship)

---

### 23. 다음 중 속성의 특성 분류가 아닌 것은?

**정답: ④ 다중값 속성**

**상세 해설:**
- **속성의 특성:**
  - **단순/복합**: 단순(원자값), 복합(여러 속성의 조합)
  - **단일값/다중값**: 단일값(하나의 값), 다중값(여러 값)
- 다중값 속성도 속성의 특성 분류에 포함됩니다. (문제 오류 가능)

---

### 24. 다음 중 관계의 선택사양(Optionality)이 아닌 것은?

**정답: ③ 일대일 관계(One-to-One)**

**상세 해설:**
- **선택사양:**
  - **필수 관계**: 모든 인스턴스가 관계를 가져야 함
  - **선택 관계**: 일부 인스턴스만 관계를 가질 수 있음
  - **조건부 필수 관계**: 특정 조건에서만 필수
- 일대일 관계는 차수(Cardinality)에 해당합니다.

---

### 25. 다음 중 데이터 모델링의 주요 개념이 아닌 것은?

**정답: ④ 인덱스**

**상세 해설:**
- **데이터 모델링의 핵심 개념:**
  - **엔티티**: 데이터를 저장하는 대상
  - **속성**: 엔티티의 특성
  - **관계**: 엔티티 간의 연관성
- 인덱스는 물리적 설계 단계에서 고려하는 개념입니다.

---

## 제2과목: SQL 기본 및 활용 (25문제)

### 26. 다음 SQL 문장의 실행 결과는?

```sql
SELECT COUNT(*) FROM EMP WHERE DEPTNO IS NULL;
```

**정답: ① NULL 값의 개수**

**상세 해설:**
- `COUNT(*)`: NULL을 포함한 모든 행을 카운트
- `COUNT(컬럼명)`: NULL을 제외하고 카운트
- `WHERE DEPTNO IS NULL`: DEPTNO가 NULL인 행만 선택
- 결과: DEPTNO가 NULL인 행의 개수 반환

---

### 27. 다음 SQL 문장에서 오류가 발생하는 것은?

```sql
SELECT EMPNO, ENAME, SAL
FROM EMP
WHERE SAL > (SELECT AVG(SAL) FROM EMP);
```

**정답: ④ 오류 없음**

**상세 해설:**
- 서브쿼리 `(SELECT AVG(SAL) FROM EMP)`는 단일 행(평균값)을 반환
- 단일 행 서브쿼리는 비교 연산자(>, <, = 등)와 함께 사용 가능
- 정상 작동하며 평균 급여보다 높은 급여를 받는 사원 조회

---

### 28. 다음 중 집계 함수가 아닌 것은?

**정답: ③ CONCAT**

**상세 해설:**
- **집계 함수:**
  - SUM, AVG, MAX, MIN, COUNT
  - GROUP BY와 함께 사용
- **CONCAT**: 문자열 연결 함수 (집계 함수 아님)
  - 예: CONCAT('Hello', 'World') → 'HelloWorld'

---

### 29. 다음 SQL 문장의 실행 결과는?

```sql
SELECT DEPTNO, COUNT(*) 
FROM EMP 
GROUP BY DEPTNO 
HAVING COUNT(*) > 5;
```

**정답: ① 부서별 사원 수가 5명 이상인 부서와 사원 수**

**상세 해설:**
- `GROUP BY DEPTNO`: 부서별로 그룹화
- `COUNT(*)`: 각 그룹의 행 수 계산
- `HAVING COUNT(*) > 5`: 그룹 조건 필터링 (5명 초과)
- `WHERE`는 행 필터링, `HAVING`은 그룹 필터링

---

### 30. 다음 중 JOIN의 종류가 아닌 것은?

**정답: ④ CROSS OUTER JOIN**

**상세 해설:**
- **JOIN 종류:**
  - INNER JOIN: 양쪽 모두 일치하는 행만
  - LEFT OUTER JOIN: 왼쪽 테이블의 모든 행
  - RIGHT OUTER JOIN: 오른쪽 테이블의 모든 행
  - FULL OUTER JOIN: 양쪽 테이블의 모든 행
  - CROSS JOIN: 카티션 곱 (CROSS OUTER JOIN은 없음)

---

### 31. 다음 SQL 문장에서 NULL 값 처리 함수는?

```sql
SELECT NVL(COMM, 0) FROM EMP;
```

**정답: ① NVL**

**상세 해설:**
- **NULL 처리 함수:**
  - **NVL**: Oracle 전용, NVL(컬럼, 대체값)
  - **COALESCE**: 표준 SQL, COALESCE(값1, 값2, ...)
  - **NULLIF**: 두 값이 같으면 NULL 반환
  - **ISNULL**: SQL Server 전용
- 문제에서 NVL을 사용했으므로 NVL이 정답

---

### 32. 다음 SQL 문장의 실행 결과는?

```sql
SELECT ROUND(123.456, 2) FROM DUAL;
```

**정답: ② 123.46**

**상세 해설:**
- `ROUND(숫자, 자릿수)`: 반올림 함수
- `ROUND(123.456, 2)`: 소수점 둘째 자리까지 반올림
- 123.456 → 소수점 셋째 자리(6)가 5 이상이므로 둘째 자리 올림
- 결과: 123.46

---

### 33. 다음 중 서브쿼리의 종류가 아닌 것은?

**정답: ③ 다중 열 서브쿼리**

**상세 해설:**
- **서브쿼리 종류:**
  - **단일 행 서브쿼리**: 하나의 행 반환
  - **다중 행 서브쿼리**: 여러 행 반환 (IN, ANY, ALL 사용)
  - **다중 열 서브쿼리**: 여러 컬럼 반환
  - **상관 서브쿼리**: 외부 쿼리의 값을 참조
- 다중 열 서브쿼리도 존재합니다. (문제 오류 가능)

---

### 34. 다음 SQL 문장에서 사용된 함수는?

```sql
SELECT SUBSTR('SQL Developer', 1, 3) FROM DUAL;
```

**정답: ② SUBSTR**

**상세 해설:**
- **문자열 함수:**
  - **SUBSTR**: Oracle, SUBSTR(문자열, 시작위치, 길이)
  - **SUBSTRING**: SQL Server, SUBSTRING(문자열, 시작위치, 길이)
  - **LEFT**: 왼쪽부터 지정 길이만큼
  - **MID**: 중간 부분 추출
- `SUBSTR('SQL Developer', 1, 3)` → 'SQL' 반환

---

### 35. 다음 SQL 문장의 실행 결과는?

```sql
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD') FROM DUAL;
```

**정답: ① 현재 날짜를 문자형으로 변환**

**상세 해설:**
- `SYSDATE`: Oracle의 현재 날짜와 시간 반환 (DATE 타입)
- `TO_CHAR`: 날짜/숫자를 문자형으로 변환
- `'YYYY-MM-DD'`: 날짜 형식 지정
- 예: 2024-01-15 형식의 문자열 반환

---

### 36. 다음 중 트랜잭션 제어문이 아닌 것은?

**정답: ④ TRUNCATE**

**상세 해설:**
- **트랜잭션 제어문 (TCL):**
  - **COMMIT**: 변경사항 확정
  - **ROLLBACK**: 변경사항 취소
  - **SAVEPOINT**: 중간 저장점 설정
- **TRUNCATE**: DDL 문으로 트랜잭션 제어문이 아님 (자동 COMMIT)

---

### 37. 다음 SQL 문장에서 사용된 연산자는?

```sql
SELECT * FROM EMP WHERE SAL BETWEEN 1000 AND 5000;
```

**정답: ③ 범위 연산자**

**상세 해설:**
- `BETWEEN A AND B`: 범위 연산자 (A 이상 B 이하)
- `SAL BETWEEN 1000 AND 5000` = `SAL >= 1000 AND SAL <= 5000`
- 비교 연산자(>, <, =)와 논리 연산자(AND, OR)의 조합

---

### 38. 다음 SQL 문장의 실행 결과는?

```sql
SELECT DEPTNO, SUM(SAL) 
FROM EMP 
GROUP BY DEPTNO 
ORDER BY SUM(SAL) DESC;
```

**정답: ① 부서별 급여 합계를 내림차순 정렬**

**상세 해설:**
- `GROUP BY DEPTNO`: 부서별 그룹화
- `SUM(SAL)`: 각 부서의 급여 합계 계산
- `ORDER BY SUM(SAL) DESC`: 급여 합계를 내림차순 정렬
- 정상 작동하며 부서별 급여 합계가 높은 순서대로 출력

---

### 39. 다음 중 DDL 문이 아닌 것은?

**정답: ④ DELETE**

**상세 해설:**
- **DDL (Data Definition Language):**
  - CREATE, ALTER, DROP, TRUNCATE, RENAME
  - 자동 COMMIT, ROLLBACK 불가
- **DELETE**: DML (Data Manipulation Language)
  - INSERT, UPDATE, DELETE, SELECT
  - COMMIT/ROLLBACK 가능

---

### 40. 다음 SQL 문장에서 사용된 함수는?

```sql
SELECT DECODE(DEPTNO, 10, 'ACCOUNTING', 20, 'RESEARCH', 'OTHER') FROM EMP;
```

**정답: ② DECODE**

**상세 해설:**
- **조건 함수:**
  - **DECODE**: Oracle 전용, IF-THEN-ELSE 기능
    - DECODE(컬럼, 값1, 결과1, 값2, 결과2, 기본값)
  - **CASE**: 표준 SQL
    - CASE WHEN 조건 THEN 결과 END
- `DECODE(DEPTNO, 10, 'ACCOUNTING', 20, 'RESEARCH', 'OTHER')`
  - DEPTNO가 10이면 'ACCOUNTING', 20이면 'RESEARCH', 그 외 'OTHER'

---

### 41. 다음 SQL 문장의 실행 결과는?

```sql
SELECT * FROM EMP WHERE ENAME LIKE 'S%';
```

**정답: ① ENAME이 'S'로 시작하는 행**

**상세 해설:**
- `LIKE`: 패턴 매칭 연산자
- `'S%'`: 'S'로 시작하는 문자열
  - `%`: 0개 이상의 문자
  - `_`: 1개의 문자
- 예: 'SMITH', 'SCOTT' 등이 매칭됨

---

### 42. 다음 중 집합 연산자가 아닌 것은?

**정답: ④ EXCEPT**

**상세 해설:**
- **Oracle 집합 연산자:**
  - **UNION**: 합집합 (중복 제거)
  - **UNION ALL**: 합집합 (중복 허용)
  - **INTERSECT**: 교집합
  - **MINUS**: 차집합
- **EXCEPT**: SQL Server에서 사용 (Oracle은 MINUS)

---

### 43. 다음 SQL 문장에서 사용된 JOIN은?

```sql
SELECT * FROM EMP E, DEPT D WHERE E.DEPTNO = D.DEPTNO;
```

**정답: ② EQUI JOIN**

**상세 해설:**
- **JOIN 종류:**
  - **EQUI JOIN**: 등호(=)를 사용한 조인 (오라클 전통 문법)
  - **INNER JOIN**: 표준 SQL 문법
  - **NATURAL JOIN**: 같은 이름의 컬럼으로 자동 조인
  - **CROSS JOIN**: 카티션 곱
- 위 문장은 EQUI JOIN (오라클 전통 문법)

---

### 44. 다음 SQL 문장의 실행 결과는?

```sql
SELECT RANK() OVER (ORDER BY SAL DESC) FROM EMP;
```

**정답: ① 급여 내림차순 순위**

**상세 해설:**
- **윈도우 함수:**
  - `RANK()`: 순위 함수
  - `ORDER BY SAL DESC`: 급여 내림차순 정렬
  - 동일 값은 같은 순위, 다음 순위는 건너뜀
    - 예: 1등, 2등, 2등, 4등, ...
- `DENSE_RANK()`: 동일 값은 같은 순위, 다음 순위는 연속
  - 예: 1등, 2등, 2등, 3등, ...

---

### 45. 다음 중 윈도우 함수가 아닌 것은?

**정답: ④ GROUP BY**

**상세 해설:**
- **윈도우 함수:**
  - ROW_NUMBER, RANK, DENSE_RANK
  - LAG, LEAD (이전/다음 행 값)
  - SUM, AVG, MAX, MIN (집계 함수의 윈도우 버전)
- **GROUP BY**: 집계를 위한 절 (윈도우 함수 아님)

---

### 46. 다음 SQL 문장에서 사용된 제약조건은?

```sql
CREATE TABLE EMP (
    EMPNO NUMBER PRIMARY KEY,
    ENAME VARCHAR2(20) NOT NULL
);
```

**정답: ① 기본키 제약조건**

**상세 해설:**
- `PRIMARY KEY`: 기본키 제약조건
  - 유일성, 최소성, 존재성, 불변성 보장
- `NOT NULL`: NULL 금지 제약조건
- 문제에서 PRIMARY KEY를 사용했으므로 기본키 제약조건이 정답

---

### 47. 다음 SQL 문장의 실행 결과는?

```sql
SELECT LENGTH('SQL Developer') FROM DUAL;
```

**정답: ① 13**

**상세 해설:**
- `LENGTH(문자열)`: 문자열의 길이 반환
- `'SQL Developer'`: 
  - S-Q-L-공백-D-e-v-e-l-o-p-e-r
  - 총 13자 (공백 포함)
- 결과: 13

---

### 48. 다음 중 뷰(VIEW)에 대한 설명으로 옳지 않은 것은?

**정답: ③ 인덱스를 생성할 수 있음**

**상세 해설:**
- **뷰의 특징:**
  - 가상 테이블 (물리적으로 데이터 저장 안 함)
  - 보안 목적으로 사용 가능
  - 복잡한 쿼리를 단순화
- **일반 뷰**: 인덱스 생성 불가
- **물리적 뷰 (Materialized View)**: 인덱스 생성 가능

---

### 49. 다음 SQL 문장에서 사용된 함수는?

```sql
SELECT TRUNC(123.456, 2) FROM DUAL;
```

**정답: ② TRUNC**

**상세 해설:**
- **숫자 함수:**
  - **TRUNC**: 절삭 (반올림 없이 버림)
    - TRUNC(123.456, 2) = 123.45
  - **ROUND**: 반올림
    - ROUND(123.456, 2) = 123.46
  - **FLOOR**: 내림 (작은 정수)
  - **CEIL**: 올림 (큰 정수)

---

### 50. 다음 SQL 문장의 실행 결과는?

```sql
SELECT SYSDATE FROM DUAL;
```

**정답: ② 현재 날짜와 시간 반환**

**상세 해설:**
- `SYSDATE`: Oracle의 현재 날짜와 시간 반환
- 반환 형식: YYYY-MM-DD HH24:MI:SS
- 예: 2024-01-15 14:30:45
- `DUAL`: Oracle의 더미 테이블 (단일 행 반환)

---

## 핵심 개념 정리

### 데이터 모델링
1. **3단계**: 개념적 → 논리적 → 물리적
2. **엔티티**: 유형, 개념, 사건
3. **정규화**: 1NF, 2NF, 3NF, BCNF
4. **관계**: 1:1, 1:M, M:N
5. **식별자**: 기본키, 외래키, 후보키, 대체키

### SQL 문법
1. **DDL**: CREATE, ALTER, DROP
2. **DML**: SELECT, INSERT, UPDATE, DELETE
3. **DCL**: GRANT, REVOKE
4. **TCL**: COMMIT, ROLLBACK, SAVEPOINT
5. **집계 함수**: COUNT, SUM, AVG, MAX, MIN
6. **윈도우 함수**: ROW_NUMBER, RANK, DENSE_RANK

### 시험 준비 전략
1. 데이터 모델링 기본 개념 완벽 이해
2. SQL 기본 문법 숙지 및 실습
3. 서브쿼리와 JOIN 연습
4. 집계 함수와 윈도우 함수 차이 이해
5. 실전 문제 풀이 및 오답 정리
